% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat-function-3d.R
\name{stat_function_3d}
\alias{stat_function_3d}
\title{3D function surface visualization}
\usage{
stat_function_3d(
  mapping = NULL,
  fun = NULL,
  data = NULL,
  geom = GeomPolygon3D,
  position = "identity",
  xlim = NULL,
  ylim = NULL,
  n = 50,
  light = lighting(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  color = NULL,
  colour = NULL,
  ...
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[=aes]{aes()}}. Since this stat
generates its own data, typically only used for additional aesthetics like
\code{fill} or \code{color} based on computed variables.}

\item{fun}{Function to evaluate. Must accept two arguments (vectors corresponding
to x and y axis values) and return a numeric vector of z values. Required parameter.}

\item{data}{The data to be displayed in this layer. Usually not needed since
the stat generates its own data from the function.}

\item{geom}{The geometric object to use display the data. Defaults to
\link{GeomPolygon3D} for proper 3D depth sorting.}

\item{position}{Position adjustment, defaults to "identity". To collapse the result
onto one 2D surface, use \code{position_on_face()}.}

\item{xlim, ylim}{Numeric vectors of length 2 giving the range for x and y values.
If \code{NULL} (default), uses the scale ranges from the plot, which can be set via
\code{xlim()} and \code{ylim()}, or trained by supplying data to the plot.}

\item{n}{Either a single integer specifying grid resolution in both dimensions,
or a vector of length 2 specifying \code{c(nx, ny)} for different resolutions.
Default is 50. Higher values create smoother surfaces but slower rendering.}

\item{light}{A lighting specification object created by \code{\link[=lighting]{lighting()}}}

\item{na.rm}{If \code{TRUE}, removes missing values from function evaluation results.
If \code{FALSE}, missing values will cause an error. Default is \code{FALSE}.}

\item{show.legend}{Logical indicating whether this layer should be included in legends.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics.}

\item{...}{Other arguments passed on to \code{layer()}, such as \code{sort_method} and \code{scale_depth}
arguments to \code{geom_polygon_3d()}.}
}
\description{
Creates 3D surfaces by evaluating a function f(x,y) = z over a regular grid.
The function is evaluated at each grid point and the resulting surface is rendered
with proper 3D depth sorting and optional lighting effects.
}
\section{Aesthetics}{

\code{stat_function_3d()} generates its own x, y, z coordinates, so typically no
positional aesthetics are needed in the mapping. However, you can use computed
variables with \code{\link[=after_stat]{after_stat()}}:
}

\section{Computed variables}{

\itemize{
\item \code{x}, \code{y}, \code{z}: Grid coordinates and function values
\item \code{light}: Computed lighting value (numeric for most methods, hex color for \code{normal_rgb})
\item \code{normal_x}, \code{normal_y}, \code{normal_z}: Surface normal components
\item \code{slope}: Gradient magnitude from surface calculations
\item \code{aspect}: Direction of steepest slope from surface calculations
\item \code{dzdx}, \code{dzdy}: Partial derivatives from surface calculations
}
}

\examples{
library(ggplot2)

# Basic function surface
ggplot() +
  stat_function_3d(fun = function(x, y) x^2 + y^2,
                   xlim = c(-2, 2), ylim = c(-2, 2)) +
  coord_3d()

# Wave function with lighting
wave_fun <- function(x, y) cos(x) + cos(y) + cos(x+y) + cos(sqrt(x^2 + y^2))
ggplot() +
  stat_function_3d(fun = wave_fun, fill = "steelblue",
                   xlim = c(-3*pi, 3*pi), ylim = c(-3*pi, 3*pi),
                   light = lighting(shade = "fill", shade_mode = "hsl")) +
  coord_3d(scales = "fixed") + theme_dark()

# Higher resolution surface with color mapping
ggplot() +
  stat_function_3d(aes(fill = after_stat(light),
                       color = after_stat(light)),
                   fun = function(x, y) sin(x) * cos(y),
                   xlim = c(-pi, pi), ylim = c(-pi, pi),
                   n = 60) +
  scale_fill_viridis_c(option = "B") +
  scale_color_viridis_c(option = "B") +
  coord_3d()

# Complex mathematical surface
saddle <- function(x, y) x^2 - y^2
ggplot() +
  stat_function_3d(aes(fill = after_stat(x)),
                   fun = saddle, color = "white",
                   xlim = c(-3, 3), ylim = c(-3, 3),
                   n = c(20, 40)) +  # Different resolution in x and y
  scale_fill_viridis_c() +
  coord_3d(scales = "fixed", ratio = c(3, 2, 1))

# Function with lighting effects
gaussian <- function(a, b) exp(-(a^2 + b^2))
ggplot() +
  stat_function_3d(fun = gaussian, color = "white",
                   light = lighting(method = "direct",
                                  direction = c(1, -1, 0.25),
                                  shade = "both")) +
  scale_fill_viridis_c() + scale_color_viridis_c() +
  coord_3d(scales = "fixed", ratio = c(1, 2, 3), expand = FALSE) +
  xlim(-3, 3) + ylim(-2, 2) + theme_light()

}
\seealso{
\code{\link[=stat_surface_3d]{stat_surface_3d()}} for surfaces from existing grid data,
\code{\link[=lighting]{lighting()}} for lighting specifications, \code{\link[=coord_3d]{coord_3d()}} for 3D coordinate systems.
}
