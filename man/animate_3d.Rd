% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/animate-3d.R
\name{animate_3d}
\alias{animate_3d}
\title{Animate a 3D plot}
\usage{
animate_3d(
  plot,
  pitch = NULL,
  roll = NULL,
  yaw = NULL,
  nframes = NULL,
  fps = NULL,
  duration = NULL,
  width = 480,
  height = 480,
  res = 96,
  renderer = gifski_renderer_3d(),
  start_pause = 0,
  end_pause = 0,
  rewind = FALSE,
  cores = 1,
  device = "png",
  progress = interactive()
)
}
\arguments{
\item{plot}{A ggplot object that uses \code{\link[=coord_3d]{coord_3d()}}.}

\item{pitch, roll, yaw}{Rotation parameters to animate. Each can be:
\itemize{
\item \code{NULL} (default): Hold at the value specified in the plot's
\code{\link[=coord_3d]{coord_3d()}} call.
\item A single numeric value: Hold at this value for all frames
(overriding the plot's coord).
\item A numeric vector of length 2+: Keyframe values that are
interpolated linearly across the animation. Keyframes are evenly
spaced, so \code{c(0, 180, 180)} with 100 frames means: start at 0,
reach 180 at frame 50, hold at 180 until frame 100.
}}

\item{nframes, fps, duration}{Control animation length and speed. Specify
any two of three; the third is computed as
\code{duration = nframes / fps}. Defaults: \code{nframes = 100},
\code{fps = 10}.}

\item{width, height}{Dimensions of the animation in pixels. Defaults to
480 x 480.}

\item{res}{Resolution in ppi for the rendered frames. Default is 96.}

\item{renderer}{A renderer function that combines image frames into
an animation file. Built-in options:
\itemize{
\item \code{gifski_renderer_3d()} (default): Renders a GIF using the
\pkg{gifski} package.
\item \code{av_renderer_3d()}: Renders a video using the \pkg{av}
package.
\item \code{file_renderer_3d()}: Returns the frame image files
without combining them.
}
Any function with signature \code{function(frames, fps)} can be used.}

\item{start_pause, end_pause}{Number of frames to hold at the beginning
and end of the animation. Default is 0.}

\item{rewind}{Logical. If \code{TRUE}, the animation plays in reverse
after completing, creating a seamless loop. Default is \code{FALSE}.}

\item{cores}{Number of CPU cores for parallel frame rendering. Default
is 1 (sequential). Values greater than 1 use \code{\link[parallel:clusterApply]{parallel::parLapply()}}
to render frames in parallel, which can significantly speed up
animation of complex plots. Note that progress reporting is not
available during parallel rendering.}

\item{device}{The graphics device to use for rendering frames.
Default is \code{"png"}. Other options include \code{"ragg_png"}
(requires the \pkg{ragg} package).}

\item{progress}{Whether to print a progress bar. Ignored when \code{cores > 1}.}
}
\value{
The return value of the renderer function. For
\code{gifski_renderer_3d()}, a \code{gif_3d} object (a file path with
class attributes for display in RStudio and knitr). For
\code{file_renderer_3d()}, a character vector of file paths.
}
\description{
Renders an animated GIF or MP4 of a rotating ggplot with \code{\link[=coord_3d]{coord_3d()}},
smoothly interpolating rotation angles across frames.
}
\examples{
\dontrun{
p <- ggplot() +
  geom_function_3d(
    fun = function(x, y) sin(x) * cos(y),
    xlim = c(-pi, pi), ylim = c(-pi, pi),
    fill = "steelblue", color = "steelblue") +
  coord_3d(light = light(mode = "hsl"))

# Simple turntable rotation
animate_3d(p, yaw = c(-30, 330))

# Orbit with pitch change
animate_3d(p, yaw = c(-30, 330), pitch = c(0, 30),
           nframes = 120, fps = 15)

# Multi-segment animation: rotate yaw, then tilt pitch
animate_3d(p, yaw = c(0, 180, 180), pitch = c(0, 0, 45))

# Parallel rendering with 4 cores
animate_3d(p, yaw = c(0, 360), cores = 4)

# Save to file
anim <- animate_3d(p, yaw = c(0, 360))
anim_save_3d(anim, "rotating_surface.gif")
}

}
\seealso{
\code{\link[=coord_3d]{coord_3d()}} for the 3D coordinate system,
\code{\link[=gifski_renderer_3d]{gifski_renderer_3d()}} and \code{\link[=file_renderer_3d]{file_renderer_3d()}} for renderer options.
}
