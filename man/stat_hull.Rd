% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat-hull.R
\name{stat_hull}
\alias{stat_hull}
\title{Create 3D convex and alpha hulls with lighting}
\usage{
stat_hull(
  mapping = NULL,
  data = NULL,
  geom = GeomPolygon3D,
  position = "identity",
  method = "alpha",
  alpha = 1,
  light = lighting("lambert"),
  inherit.aes = TRUE,
  ...
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[=aes]{aes()}}. The required
aesthetics are \code{x}, \code{y}, and \code{z}. Additional aesthetics can use computed
variables with \code{\link[=after_stat]{after_stat()}}.}

\item{data}{The data to be displayed in this layer.}

\item{geom}{The geometric object to use display the data. Defaults to
\link{GeomPolygon3D} for proper 3D depth sorting.}

\item{position}{Position adjustment, defaults to "identity".}

\item{method}{Triangulation method. Either:
\itemize{
\item \code{"hull"}: Convex hull triangulation (works well for convex shapes like spheres)
\item \code{"alpha"}: Alpha shape triangulation (can capture non-convex topologies like toruses)
}}

\item{alpha}{Alpha parameter for alpha shape triangulation. Smaller values create
more detailed surfaces but may fragment. Larger values create smoother surfaces
but may fill holes. Only used when \code{method = "alpha"}.}

\item{light}{A lighting specification object created by \code{lighting()}}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics.}

\item{...}{Other arguments passed on to \code{\link[=layer]{layer()}}.}
}
\description{
\code{stat_hull()} creates triangulated surfaces from 3D point clouds using either
convex hull or alpha shape algorithms. It computes surface normals and applies
various lighting models to create realistic 3D surface visualizations.
}
\section{Computed variables}{

\itemize{
\item \code{light}: Computed lighting value (numeric for most methods, hex color for \code{normal_rgb})
\item \code{normal_x}, \code{normal_y}, \code{normal_z}: Surface normal components
\item \code{triangle_index}: Sequential triangle number (useful for debugging)
\item \code{face_id}: Triangle group identifier
}
}

\section{Aesthetics}{

\code{stat_hull()} requires the following aesthetics:
\itemize{
\item \strong{x}: X coordinate
\item \strong{y}: Y coordinate
\item \strong{z}: Z coordinate
}

Computed variables can be accessed using \code{\link[=after_stat]{after_stat()}}:
\itemize{
\item \code{after_stat(light)}: Lighting values
\item \code{after_stat(normal_x)}: X component of surface normal
\item \code{after_stat(normal_y)}: Y component of surface normal
\item \code{after_stat(normal_z)}: Z component of surface normal
}
}

\examples{
library(ggplot2)

# Generate sphere points
set.seed(123)
theta <- runif(200, 0, 2*pi)
phi <- acos(runif(200, -1, 1))
sphere_df <- data.frame(
  x = sin(phi) * cos(theta),
  y = sin(phi) * sin(theta),
  z = cos(phi)
)

# Basic surface with Lambert lighting
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)), method = "hull") +
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

# Surface with normal-to-RGB coloring
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               method = "hull", light = "normal_rgb") +
  coord_3d()

# Quantized lighting (cel shading effect)
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               method = "hull", lighting = "quantize", n_levels = 3) +
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

# Signed lighting with continuous gradient
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               method = "hull", light = "signed") +
  scale_fill_gradient2(low = "blue", mid = "gray", high = "white") +
  coord_3d()

# Custom light direction
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               method = "hull", light_dir = c(1, 1, 1)) +
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

# Rotated RGB color scheme
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)), light = "normal_rgb",
               method = "hull") +
  coord_3d()

}
\seealso{
\code{\link[=coord_3d]{coord_3d()}} for 3D coordinate systems, \link{geom_polygon_3d} for the
default geometry with depth sorting.
}
