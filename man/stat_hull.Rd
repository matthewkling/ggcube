% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat-hull.R
\name{stat_hull}
\alias{stat_hull}
\title{Create 3D convex and alpha hulls with lighting}
\usage{
stat_hull(
  mapping = NULL,
  data = NULL,
  geom = GeomPolygon3D,
  position = "identity",
  method = "alpha",
  alpha = 1,
  light = lighting("lambert"),
  inherit.aes = TRUE,
  ...
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[=aes]{aes()}}. The required
aesthetics are \code{x}, \code{y}, and \code{z}. Additional aesthetics can use computed
variables with \code{\link[=after_stat]{after_stat()}}.}

\item{data}{The data to be displayed in this layer.}

\item{geom}{The geometric object to use display the data. Defaults to
\link{GeomPolygon3D} for proper 3D depth sorting.}

\item{position}{Position adjustment, defaults to "identity".}

\item{method}{Triangulation method. Either:
\itemize{
\item \code{"hull"}: Convex hull triangulation (works well for convex shapes like spheres)
\item \code{"alpha"}: Alpha shape triangulation (can capture non-convex topologies like toruses)
}}

\item{alpha}{Alpha parameter for alpha shape triangulation. \strong{IMPORTANT:} Alpha shapes
are extremely sensitive to the coordinate scales of your data. See Details section.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics.}

\item{...}{Other arguments passed on to \code{\link[=layer]{layer()}}.}

\item{lighting_spec}{A lighting specification object created by \code{lighting()}}
}
\description{
\code{stat_hull()} turns 3D point clouds into surface hulls consisting of triangular polygons,
using either convex hull or alpha shape algorithms. It computes surface normals and applies
various lighting models to create realistic 3D surface visualizations.
}
\section{Alpha scale sensitivity}{

\strong{Alpha shape method is highly sensitive to coordinate scales.} The \code{alpha} parameter
that works for data scaled 0-1 will likely fail for data scaled 0-1000.

\strong{Guidelines for choosing alpha:}
\itemize{
\item Start with \code{alpha = 1.0} and adjust based on results
\item For data with mixed scales (e.g., x: 0-1, y: 0-1000), consider rescaling your data first
\item Larger alpha values → smoother, more connected surfaces
\item Smaller alpha values → more detailed surfaces, but may fragment
\item If you get no triangles, try increasing alpha by 10x
\item If surface fills unwanted holes, try decreasing alpha by 10x
}

\strong{Example scale effects:}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# These require very different alpha values:
data_small <- data.frame(x = runif(100, 0, 1), y = runif(100, 0, 1), z = runif(100, 0, 1))
data_large <- data.frame(x = runif(100, 0, 100), y = runif(100, 0, 100), z = runif(100, 0, 100))

stat_hull(data = data_small, alpha = 0.5)    # Might work well
stat_hull(data = data_large, alpha = 50)     # Might need much larger alpha
}\if{html}{\out{</div>}}
}

\section{Computed variables}{

\itemize{
\item \code{light}: Computed lighting value (numeric for most methods, hex color for \code{normal_rgb})
\item \code{normal_x}, \code{normal_y}, \code{normal_z}: Surface normal components
\item \code{triangle_index}: Sequential triangle number (useful for debugging)
\item \code{face_id}: Triangle group identifier
}
}

\section{Aesthetics}{

\code{stat_hull()} requires the following aesthetics:
\itemize{
\item \strong{x}: X coordinate
\item \strong{y}: Y coordinate
\item \strong{z}: Z coordinate
}

Computed variables can be accessed using \code{\link[=after_stat]{after_stat()}}:
\itemize{
\item \code{after_stat(light)}: Lighting values
\item \code{after_stat(normal_x)}: X component of surface normal
\item \code{after_stat(normal_y)}: Y component of surface normal
\item \code{after_stat(normal_z)}: Z component of surface normal
}
}

\examples{
library(ggplot2)

# Generate sphere points (coordinates roughly 0-1 scale)
set.seed(123)
theta <- runif(200, 0, 2*pi)
phi <- acos(runif(200, -1, 1))
sphere_df <- data.frame(
  x = sin(phi) * cos(theta),
  y = sin(phi) * sin(theta),
  z = cos(phi)
)

# Convex hull (no scale sensitivity)
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_hull(aes(fill = after_stat(light)), method = "hull") +
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

# Alpha shape (scale-sensitive - alpha ~1 works for unit sphere)
ggplot(sphere_df, aes(x, y, z = z)) +
  stat_hull(aes(fill = after_stat(light)), method = "alpha", alpha = 1.0) +
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

# For larger coordinate scales, increase alpha proportionally:
sphere_large <- sphere_df * 100  # Scale up by 100x
ggplot(sphere_large, aes(x, y, z = z)) +
  stat_hull(aes(fill = after_stat(light)),
            method = "alpha", alpha = 100) +  # Increase alpha ~100x
  scale_fill_gradient(low = "black", high = "white") +
  coord_3d()

}
\seealso{
\code{\link[=coord_3d]{coord_3d()}} for 3D coordinate systems, \link{geom_polygon_3d} for the
default geometry with depth sorting, \code{\link[=lighting]{lighting()}} for lighting specifications.
}
