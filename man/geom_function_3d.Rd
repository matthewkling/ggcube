% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom-function-3d.R
\name{geom_function_3d}
\alias{geom_function_3d}
\alias{stat_function_3d}
\title{3D function as a continuous surface}
\usage{
geom_function_3d(
  mapping = NULL,
  data = NULL,
  stat = StatFunction3D,
  position = "identity",
  ...,
  fun = NULL,
  xlim = NULL,
  ylim = NULL,
  n = NULL,
  grid = NULL,
  direction = NULL,
  light = ggcube::light(),
  cull_backfaces = FALSE,
  sort_method = NULL,
  force_convex = TRUE,
  scale_depth = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_function_3d(
  mapping = NULL,
  data = NULL,
  geom = GeomPolygon3D,
  position = "identity",
  ...,
  fun = NULL,
  xlim = NULL,
  ylim = NULL,
  n = NULL,
  grid = NULL,
  direction = NULL,
  cull_backfaces = FALSE,
  sort_method = NULL,
  force_convex = TRUE,
  scale_depth = TRUE,
  light = ggcube::light(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[=aes]{aes()}}. Since this stat
generates its own data, typically only used for additional aesthetics like
\code{fill} or \code{color} based on computed variables. Fill is mapped to \code{after_stat(z)} by default.}

\item{data}{The data to be displayed in this layer. Usually not needed since
the stat generates its own data from the function.}

\item{stat}{The statistical transformation to use on the data. Defaults to \code{StatFunction3D}.}

\item{position}{Position adjustment, defaults to "identity". To collapse the result
onto one 2D surface, use \code{position_on_face()}.}

\item{...}{Other arguments passed on to the the layer function (typically GeomPolygon3D), such as
aesthetics like \code{colour}, \code{fill}, \code{linewidth}, etc.}

\item{fun}{Function to evaluate. Must accept two arguments (vectors corresponding
to x and y axis values) and return a numeric vector of z values. Required parameter.}

\item{xlim, ylim}{Numeric vectors of length 2 giving the range for x and y values.
If \code{NULL} (default), uses the scale ranges from the plot, which can be set via
\code{xlim()} and \code{ylim()}, or trained by supplying data to the plot.}

\item{grid, n, direction}{Parameters determining the geometry, resolution, and
orientation of the surface grid. See \link{grid_generation} for details.}

\item{light}{A lighting specification object created by \code{\link[=light]{light()}}, or NULL to disable shading.}

\item{cull_backfaces, sort_method, force_convex, scale_depth}{Advanced polygon
rendering parameters. See \link{polygon_rendering} for details.}

\item{na.rm}{If \code{FALSE}, missing values are removed.}

\item{show.legend}{Logical indicating whether this layer should be included in legends.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics.}

\item{geom}{The geometric object used to display the data. Defaults to \code{GeomPolygon3D}.}
}
\description{
A 3D version of \code{ggplot2::stat_function()}.
Creates surfaces by evaluating a function f(x,y) = z over a regular grid.
The function is evaluated at each grid point and the resulting surface is rendered
as a 3D surface.
}
\section{Aesthetics}{

\code{stat_function_3d()} generates its own x, y, z coordinates, so typically no
positional aesthetics are needed in the mapping. However, you can use computed
variables with \code{\link[=after_stat]{after_stat()}}.
}

\section{Computed variables}{

The following computed variables are available via \code{after_stat()}:
\itemize{
\item \code{x}, \code{y}, \code{z}: Grid coordinates and function values
\item \code{normal_x}, \code{normal_y}, \code{normal_z}: Surface normal components
\item \code{slope}: Gradient magnitude from surface calculations
\item \code{aspect}: Direction of steepest slope from surface calculations
\item \code{dzdx}, \code{dzdy}: Partial derivatives from surface calculation
}
}

\examples{
library(ggplot2)

# Basic function surface
ggplot() +
  geom_function_3d(fun = function(a, b) exp(-(a^2 + b^2)),
                   xlim = c(-2, 2), ylim = c(-2, 2),
                   light = NULL, color = "white") +
  coord_3d() +
  scale_fill_viridis_c()

# Wave function with lighting
wave_fun <- function(x, y) cos(x) + cos(y) + cos(x+y) + cos(sqrt(x^2 + y^2))
ggplot() +
  geom_function_3d(fun = wave_fun, fill = "steelblue",
                   xlim = c(-3*pi, 3*pi), ylim = c(-3*pi, 3*pi),
                   light = light(method = "direct", mode = "hsl",
                          contrast = .8, direction = c(1, -1, 1))) +
  coord_3d(scales = "fixed") + theme_dark()

# Use after_stat to access computed surface-orientation variables
ggplot() +
  geom_function_3d(aes(fill = after_stat(dzdx),
                       color = after_stat(dzdx)),
                   fun = function(x, y) sin(x) * cos(y),
                   xlim = c(-pi, pi), ylim = c(-pi, pi),
                   light = NULL) +
  scale_fill_viridis_c(option = "B") +
  scale_color_viridis_c(option = "B") +
  coord_3d(scales = "fixed")

# Use "filtering" functions to constrain output domain
ggplot() +
  geom_function_3d(fun = function(a, b) {
    ifelse(sqrt(a^2 + b^2) < 2, exp(-(a^2 + b^2)), NA)},
    xlim = c(-2, 2), ylim = c(-2, 2), color = "white") +
  coord_3d() +
  scale_fill_viridis_c() +
  guides(fill = guide_colorbar_3d())

# Specify alternative grid geometry
ggplot() +
  geom_function_3d(fun = function(a, b) exp(-(a^2 + b^2)),
    xlim = c(-2, 2), ylim = c(-2, 2), color = "white",
    grid = "tri", n = 30, direction = "y") +
  coord_3d() +
  scale_fill_viridis_c() +
  guides(fill = guide_colorbar_3d())

}
\seealso{
\code{\link[=stat_surface_3d]{stat_surface_3d()}} for surfaces from existing grid data,
\code{\link[=make_tile_grid]{make_tile_grid()}} for details about grid geometry options,
\code{\link[=light]{light()}} for lighting specifications,
\code{\link[=coord_3d]{coord_3d()}} for 3D coordinate systems.
}
