% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lighting.R
\name{lighting}
\alias{lighting}
\title{Create lighting specification for 3D surface rendering with positional light support}
\usage{
lighting(
  method = "lambert",
  direction = c(1, 1, 1),
  position = NULL,
  distance_falloff = FALSE,
  levels = 3,
  clamp_negative = TRUE,
  blend = "neither",
  blend_strength = 1,
  blend_mode = "hsv"
)
}
\arguments{
\item{method}{Character string specifying lighting model:
\itemize{
\item \code{"lambert"}: Standard diffuse lighting (surfaces facing away are dark)
\item \code{"signed"}: Continuous lighting gradient including negative values
\item \code{"ambient"}: Uniform lighting with no directional component
\item \code{"quantize"}: Quantized lighting with discrete levels
\item \code{"normal_rgb"}: Map surface normals to RGB colors
\item \code{"normal_x"}, \code{"normal_y"}, \code{"normal_z"}: Individual normal components
}}

\item{direction}{Numeric vector of length 3 specifying light direction in 3D space
for directional lighting. Only used if \code{position} is NULL. Default is \code{c(1, 1, 1)}.}

\item{position}{Numeric vector of length 3 specifying light source position in
data coordinate space for positional lighting. When specified, each face gets
its own light direction calculated from the light position to the face center.
Mutually exclusive with \code{direction}. Default is NULL (use directional lighting).}

\item{distance_falloff}{Logical indicating whether to apply distance-based
intensity falloff for positional lighting using inverse square law
(intensity ∝ 1/distance²). Only used when \code{position} is specified.
Default is FALSE.}

\item{levels}{Integer number of discrete levels for \code{method = "quantize"}.
Default is 3.}

\item{clamp_negative}{Logical indicating whether to clamp negative lighting values
to the lowest level when using \code{method = "quantize"}. Default is TRUE.}

\item{blend}{Character string specifying which color aesthetics to blend with lighting.
Options: "neither" (no blending), "fill" (blend fill colors only),
"color"/"colour" (blend border colors only), or "both" (blend both fill and border).
Default is "neither".}

\item{blend_strength}{Numeric value controlling the intensity of lighting blending.
1.0 gives full black-to-white range, 0.5 gives subtle lighting effects.
Only used when \code{blend} is not "neither". Default is 1.0.}

\item{blend_mode}{Character string specifying color blending mode when \code{blend} is not "neither":
\itemize{
\item \code{"hsv"}: Modifies HSV brightness/value component (can affect color vibrancy)
\item \code{"hsl"}: Modifies HSL lightness component (preserves saturation better)
}
Default is "hsv".}
}
\value{
A \code{lighting} object that can be passed to 3D surface stats.
}
\description{
Creates a lighting specification object that supports both directional lighting
(parallel rays like sunlight) and positional lighting (point light sources with
per-face light directions and optional distance falloff).
}
\examples{
library(ggplot2)
data(mountain)

# Directional lighting (classic hillshading)
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               light = lighting("lambert", direction = c(1, 1, 1))) +
  coord_3d()

# Blended lighting with material colors using HSV
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = z),
               light = lighting("lambert", blend = "fill", blend_mode = "hsv")) +
  scale_fill_viridis_c() +
  coord_3d()

# Blended lighting with HSL mode (preserves saturation better)
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = z),
               light = lighting("lambert", blend = "fill", blend_mode = "hsl")) +
  scale_fill_viridis_c() +
  coord_3d()

# Blend both fill and border colors to eliminate gaps
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = z, colour = z),
               light = lighting("lambert", blend = "both")) +
  scale_fill_viridis_c() +
  scale_colour_viridis_c() +
  coord_3d()

# Positional lighting (point light source)
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               light = lighting("lambert", position = c(50, 30, 200))) +
  coord_3d()

# Positional lighting with distance falloff
ggplot(mountain, aes(x, y, z = z)) +
  stat_surface(aes(fill = after_stat(light)),
               light = lighting("lambert", position = c(50, 30, 200),
                               distance_falloff = TRUE)) +
  coord_3d()

# Voxel scene with positional lighting
voxel_data <- data.frame(
  x = c(1, 2, 3, 2, 1),
  y = c(1, 1, 2, 3, 2),
  z = c(1, 2, 1, 1, 3)
)
ggplot(voxel_data, aes(x, y, z)) +
  stat_voxel(aes(fill = after_stat(light)),
             light = lighting("lambert", position = c(2, 2, 5))) +
  coord_3d()

}
\seealso{
\code{\link{stat_surface}}, \code{\link{stat_voxel}}, \code{\link{stat_pillar}}
}
